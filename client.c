//
// Created by ubuntu on 12.06.2021.
//

#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include "client.h"
#include "customDefinitions.h"

static volatile  int s_iContinue = 1;
static volatile int s_iReadyToRead = 0;
static pid_t s_ServerPID = 0;

static int getRandomFileID(void)
{
    return rand() % MAX_FILE_COUNT;
}

void handleWriteOperationFinishedSignal(int sig, siginfo_t *info, void *context)
{
    printf("Signal received\n");
    // CTRL+C signal from user
    if (sig == SIGINT)
    {
        s_iContinue = 0;
    }
    // Ready To Read signal from server
    else if (sig == SIGUSR1)
    {
        s_ServerPID = info->si_pid;     // store server pid for terminate signal
        s_iReadyToRead = 1;             // write operation completed by server
    }
}

int main() {
    int iSharedMemoryID = -1;
    int iMessageID = -1;
    int iCurrentFileID;
    key_t key;
    sharedMemoryStruct *sharedMemory = NULL;
    messageQueueMessage message;
    struct sigaction sa;

    printf("Greetings From Client!\n");
    srand(time(NULL));

    // listen SIGUSR1 signal which will be generated by server when file write operation completed
    sa.sa_flags = SA_SIGINFO;
    sa.sa_sigaction = handleWriteOperationFinishedSignal;
    sigaction(SIGUSR1, &sa, NULL);

    signal(SIGINT, handleWriteOperationFinishedSignal);

    // generate unique key for shared memory and message queue operations
    key = ftok(KEY_PATH, KEY_ID);

    // create a shared memory
    iSharedMemoryID = shmget(IPC_PRIVATE, sizeof(sharedMemoryStruct), IPC_CREAT | 0666);
    if (iSharedMemoryID < 0) {
        printf("Shared Memory segment cannot be created\n");
        exit(1);
    }

    // attach to shared memory segment
    sharedMemory = shmat(iSharedMemoryID,NULL,0);
    if (sharedMemory < 0) {
        printf("Shared Memory segment cannot be attached\n");
        exit(1);
    }

    // set message fields
    message.mtype = MESSAGE_TYPE;
    message.message.iProcessID = getpid();
    message.message.iSharedMemoryAddr = iSharedMemoryID;

    // get message queue identifier
    iMessageID = msgget(key, IPC_CREAT | 0666);
    if (iMessageID < 0) {
        printf("Mailbox message cannot be created\n");
        exit(1);
    }

    while (s_iContinue == 1)
    {
        iCurrentFileID = getRandomFileID();
        printf("Requested file id: [%d]\n", iCurrentFileID);

        // set current requested file id
        message.message.iFileID = iCurrentFileID;

        // initialize sharedMemory structure
        sharedMemory->iWrittenBytes = 0;
        memset(&sharedMemory->strBuffer, 0, sizeof(char) * MAX_FILE_SIZE);

        // send message to server
        if (msgsnd(iMessageID, &message, sizeof(message), IPC_NOWAIT) < 0)
        {
            printf("Mailbox message cannot be sent\n");
            exit(1);
        }

        // wait for server to finish write operation
        while ((s_iContinue == 1) && (s_iReadyToRead != 1))
        {
            sleep(1);
        }

        // file write operation completed by server
        printf("Requested file content [%d bytes]:\n", sharedMemory->iWrittenBytes);
        printf("%s\n", sharedMemory->strBuffer);
        printf("===== Press CTRL+C To Stop =====\n");

        s_iReadyToRead = 0;

        sleep(1);
    }

    //detach from shared memory
    shmdt(sharedMemory);
    // destroy the shared memory
    shmctl(iSharedMemoryID, IPC_RMID,NULL);

    // send terminate signal to server
    kill(s_ServerPID, SIGUSR2);

    return 0;
}
